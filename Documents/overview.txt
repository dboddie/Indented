Overview
--------

This document is incomplete. See the examples in the Examples directory for
an overview of the syntax used for the language. The syntax is subject to
change, although it might be interesting to make it configurable.

The compiler is currently written in Python. Ideas for a compiler written in
assembly language are written inline as indented paragraphs.

Statements are parsed and compiled immediately, with statements separated by
newlines and possibly other symbols like commas, semicolons or colons.
If any part of this fails then the generated code is simply discarded and an
error reported.

Control flow structures and definitions end before the next non-empty line
with the same or less indentation, or at the end of the file.

Function definitions are stored in a list as they are parsed. Each definition
includes information about its name, arguments, local variables, base address
and return type information.

  Function definitions are stored in the code area, possibly a linked list of
  names and routines.

Compiled code is written using a set of functions in the generator module. As
noted above, generated code that is not needed is discarded immediately and
compilation will stop with an error if necessary.

  Compilation occurs on the compilation stack, a bottom-up stack whose frames
  contain position-independent code that is copied into function definitions
  when it is complete, or discarded if incomplete or invalid.

Apart from the system's call stack, there are two stacks in use: a value stack
and a call stack. The value stack holds variable values, temporary values,
arguments to functions and return values. The call stack holds return addresses
in the bytecode for functions.

  A variable stack will hold local variables. The sizes of these are determined
  and recorded during the compilation of each function so that code to allocate
  and free space can be compiled in the body of the function.

A set of routines is written for the target platform that interpret the
bytecode generated by the compiler. Since we are typically only running one
compiled program at once on the target platform, we can reduce the size of the
overhead required by the routines by only including those required for the
bytecodes that are used by each program. We can also save space by constructing
a specialised jump table for this subset of bytecodes. A generic runtime that
needed to support programs with different sets of bytecodes could not be
optimised in either of these ways.


Grammar
-------

This isn't a formal description but more of a general idea of how source code
is structured and processed by the compiler.

<program> = [<definition> | <control> | <statement>]+

<definition> = "def" <name> (<var name> "(" <var type> ")")+ <body>

<control> = ("if" <expression> <body>) | ("while" <expression> <body>)

<statement> = [<name> "="] <expression> <separator>

<body> = <indent> (<control> | <return> | <statement>)+ <dedent>

<value> = <number> | <string>

<built-in call> = "_addr" "(" [<argument>+] ")"

<expression> = ["("] <operand> [<operator> <operand>]+ [")"]

<operand> = ["not" | "-"] <operand value>

<operand value> = <value> | <variable> | <function call> | <system call>

<system call> = _call "(" <address> [<A> [<X> [<Y>]]] ")"

<function call> = <name> "(" [<argument>+] ")"

<return> = "return" [<expression>]

<operation> = "==" | "!=" | "<" | ">" | "+" | "-" | "*" | "/" | "and" | "or" | "&" | "<<" | ">>" <operand>

<separator> = <newline> | <eof>


Example code (function definition)
----------------------------------

The following code is taken from Examples/def-11.txt:

  def factorial x (byte)
      if x < 2
          return 1
      if x > 1
          return x * factorial ( x - 1 )

  C = factorial ( 3 )

The "def" keyword starts compilation of a function with the name and
arguments specified before the first newline. The type of each argument is
given in parentheses after each name.

The function body follows and continues until the indentation returns to the
level of the "def" keyword.

As the "if" keyword is encountered, control passes to handler functions that
compile code for these control flow structures. Variable references or
constants are compiled to code that loads the relevant value onto the value
stack.

As operators, such as "<", are encountered, control passes to handler functions
that parse the required number of additional arguments, compiling code to
handle them and produce a result. When used as part of a control flow block,
the handler function for the surrounding statement will generate code to handle
the result.

Although it may be possible to infer the types associated with each parameter
from the way they are used in the function, we are not aiming to make the
parser complex enough to achieve this. The type is defined by the parameter
in the function definition and this is propagated to other variables by
assignment and through operations.


Example code (variable definition)
----------------------------------

The following code is taken from Examples/assignment-1.txt:

  a = 1

When the "a" name is encountered, it is initially undefined. This would be an
error if we were trying to use its value, but we are defining it. This means
that it must be immediately followed by an assignment operator. The value
assigned to "a" in this case is a constant so the type can be inferred.


Problems, Solutions and Workarounds
-----------------------------------

The return types of functions are not declared in advance, making it
problematic when a recursive function call is encountered because we rely on
having type size information immediately available when parsing. This is
currently worked around by allowing return calls to update the function
information, but it means that functions need to return a concrete value
earlier than calls to themselves.

Consider storing the current frame address on the call stack instead of the
value stack.

System calls could be defined in the same way as functions, using appropriately
named parameters and simply containing a return statement. An opcode would be
generated for the actual system call which packs the arguments into the
appropriate registers and calls the system routine, writing any result back
to the stack, ready to be returned by the function. The opcode should be
explicitly given, using a keyword to represent it in programs.

def vdu ch (byte)
    _call(0xffee ch)

Functions that should return a value need to check for a trailing return to
ensure that a default value is returned. By pre-allocating stack space for
return values and incorporating the code for assigning return values to that
space, we can ensure that this happens whether a function exits with or without
a return statement.

For strings, but certainly for arrays, it would be useful to avoid passing them
by value, so the opcodes for loading strings and arrays could just push their
addresses onto the stack. This would also make it possible to use arrays with
system calls. If strings are allocated on a heap then their sizes could be
changed. Anything that refers to the string should refer to its address entry
so that the address can be changed as objects are moved around on the heap.


Types and Interfaces
--------------------

For a low-level implementation of a language, it is easy to define some fixed
types and hard-code how they are handled. So, the relationships between them
might involve specifying concrete properties of them, such as their precision,
how a value of one type can be cast to a value of a different type, and which
operations can be performed on them.

In object-oriented languages, types might be represented by classes with
particular interfaces. However, the use of inheritance to determine which types
are compatible can rule out the use of types which are interoperable under
certain circumstances. The use of inheritance to determine compatibility in
languages like Python is often a distraction from other mechanisms that give
the language its flexibility.

Compatibility between objects with similar interfaces can be difficult to
express concisely, so the use of type names can be a useful shorthand notation.
However, expressing these types in an inheritance hierarchy can be limiting, so
we could consider using a graph to express the relations between types, or use
notation that allows us to emphasise which interfaces are important in each
case. We could use a parallel set of shorthand names that describe interfaces.
However, storage requirements of values is still something that we need to
specify in situations where memory needs to be allocated for values.


Heap
----

The initial runtime only uses stacks, which makes use of variable-sized objects
difficult. As an intermediate step between allocating space for a separate heap
we could use the current stack frame as a heap, moving objects into parent
frames as required, and possibly compacting frames before child frames are
created.

Since the positions of variables in frames are usually decided at compile-time,
we might need to introduce variable frame indices and opcodes for handling
these (maybe indirection opcodes) if we intend to move variables around at
run-time.

It might be interesting to consider heap "frames" that contain and manage
multiple objects using relative positions within the frame in order to reduce
the amount of management work when reclaiming space within a heap at a low
level.


Virtual Machine Instructions
----------------------------

Instruction                 Operands (byte-sized)                   Arguments on the stack (top is last)
--------------------------------------------------------------------------------------------------------
load_number                         <size>, size * <value>          -
load_byte                           <value>                         -
compare_equals                      <size>                          size * <value1>, size * <value2>
compare_equals_byte                 -                               <value1>, <value2>
compare_not_equals                  <size>                          size * <value1>, size * <value2>
compare_not_equals_byte             -                               <value1>, <value2>
compare_less_than                   <size>                          size * <value1>, size * <value2>
compare_less_than_byte              -                               <value1>, <value2>
compare_greater_than                <size>                          size * <value1>, size * <value2>
compare_greater_than_byte           -                               <value1>, <value2>
add                                 <size>                          size * <value1>, size * <value2>
add_byte                            -                               <value1>, <value2>
add_byte_constant                   <value2>                        <value1>
subtract                            <size>                          size * <value1>, size * <value2>
subtract_byte                       -                               <value1>, <value2>
subtract_byte_constant              <value2>                        <value1>
multiply                            <size>                          size * <value1>, size * <value2>
divide                              <size>                          size * <value1>, size * <value2>
logical_and                         -                               <value1>, <value2>
logical_or                          -                               <value1>, <value2>
logical_not                         -                               <value1>, <value2>
minus                               <size>                          size * <value>
bitwise_and                         <size>                          size * <value1>, size * <value2>
bitwise_and_byte                    -                               <value1>, <value2>
bitwise_and_byte_constant           <value2>                        <value1>
bitwise_or                          <size>                          size * <value1>, size * <value2>
bitwise_or_byte                     -                               <value1>, <value2>
bitwise_or_byte_constant            <value2>                        <value1>
bitwise_eor                         <size>                          size * <value1>, size * <value2>
bitwise_eor_byte                    -                               <value1>, <value2>
bitwise_eor_byte_constant           <value2>                        <value1>
left_shift                          <size>                          size * <value1>, size * <value2>
right_shift                         <size>                          size * <value1>, size * <value2>
branch_forward_if_false             <offset>                        <value>
branch_forward                      <offset>                        -
branch_backward_if_false            <offset>                        <value>
branch_backward                     <offset>                        -
jump_if_false                       <address>...                    <value>
jump                                <address>...                    -
load_local                          <offset> <size>                 -
load_local_byte                     <offset>                        -
load_global                         <offset> <size>                 -
assign_local                        <offset> <size>                 -
assign_local_byte                   <offset>                        -
function_return                     -                               <address>...
function_call                       <address>...                    -
load_current_frame_address          -                               -
store_stack_top_in_current_frame    <size>                          -
allocate_stack_space                <size>                          -
free_stack_space                    <size>                          -
pop_current_frame_address           -                               <address>...
copy_value                          <offset> <size>                 -
sys_call                            <size>                          <registers>... <address>...
get_variable_address                <offset>                        -
load_array_value                    <offset> <index size> <size>    <index>...
load_array_byte_value               <offset>                        <index>
store_array_value                   <offset> <index size> <size>    <index>...
store_array_byte_value              <offset>                        <index>
end                                 -                               -
