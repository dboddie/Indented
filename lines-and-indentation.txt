Overview
--------

Statements are parsed and compiled immediately, with statements separated by
newlines and possibly other symbols like commas, semicolons or colons.

Control flow structures and definitions end before the next non-empty line
with the same or less indentation, or at the end of the file.

Function definitions are stored in the code area, possibly a linked list of
names and routines.

Compilation occurs on the compilation stack, a bottom-up stack whose frames
contain position-independent code that is copied into function definitions
when it is complete, or discarded if incomplete or invalid.

Arguments to functions, temporary values and return values are stored on the
value stack.

The system's call stack is used for return addresses in compiled code.

A variable stack will hold local variables. The sizes of these are determined
and recorded during the compilation of each function so that code to allocate
and free space can be compiled in the body of the function.

Initially, the grammar will be loosely defined, allowing both valid and invalid
syntax to some extent.

Grammar
-------

<function> =
"def" <name> <var0> "=" <value0> <var1> "=" <value1> ...
<body>

<body> =
[indent]
    <statement0>
    <statement1>
    ...
[dedent]

<statement> = <if> | <while> | <assignment>

<if> =
"if" <expression>
<body>

<while> =
"while" <expression>
<body>

<assignment> =
<name> "=" <expression>

<expression> =
<value> [<operator> <value>] ...

<value> = <name> | <constant>

<operator> = "==" | "!=" | "+" | "-"

Example code (function definition)
----------------------------------

def factorial x (int8)
    if x == 0
        return 1
    else
        return x * factorial(x - 1)

The "def" keyword starts compilation of a function with the name and
arguments specified before the first newline. The definition ends at the
position in the file described above. The type of each argument is given in
parentheses after each name.

The function name could be temporarily added to the module/global dictionary
when it is first encountered, allowing the definition to contain references
to itself. However, this would not allow mutually recursive functions to be
defined, so perhaps introducing a placeholder for unresolved function calls
could be an alternative mechanism for both types of recursion.

As "if" and "else" keywords are encountered, control passes to handler
functions that compile code for these control flow structures.

Variable references or constants are compiled to code that loads the
relevant value onto the value stack.

As operators, such as "==", are encountered, control passes to handler
functions that parse the required number of additional arguments, compiling
code to handle them and produce a result. When used as part of a control flow
block, the handler function for the surrounding statement will generate code
to handle the result.

Although it may be possible to infer the types associated with each parameter
from the way they are used in the function, we are not aiming to make the
parser complex enough to achieve this.

Example code (variable definition)
----------------------------------

x = 0

When the "x" name is encountered, it is initially undefined. This would be an
error if we were trying to use its value, but we are defining it. This means
that it must be immediately followed by an assignment operator.

Problems
--------

See the lines.py file for a list of current problems in the first
implementation.

The return types of functions are not declared in advance, making it
problematic when a recursive function call is encountered because we rely on
having type size information immediately available when parsing. This is
currently worked around by allowing return calls to update the function
information, but it means that functions need to return a concrete value
earlier than calls to themselves.

Consider storing the current frame address on the call stack instead of the
value stack.

System calls could be defined in the same way as functions, using appropriately
named parameters and simply containing a return statement. An opcode would be
generated for the actual system call which packs the arguments into the
appropriate registers and calls the system routine, writing any result back
to the stack, ready to be returned by the function. The opcode should be
explicitly given, using a keyword to represent it in programs.

def vdu ch (byte)
    _call(0xffee ch)

Functions that should return a value need to check for a trailing return to
ensure that a default value is returned. By pre-allocating stack space for
return values and incorporating the code for assigning return values to that
space, we can ensure that this happens whether a function exits with or without
a return statement.

For strings, but certainly for arrays, it would be useful to avoid passing them
by value, so the opcodes for loading strings and arrays could just push their
addresses onto the stack. This would also make it possible to use arrays with
system calls.
